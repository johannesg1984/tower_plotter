from collections import OrderedDict
from collections import defaultdict
import os
from dataclasses import dataclass
import time
import io
import pandas as pd


def check_all_same(list):
   """A function that check if all items in a list are identical"""
   return list.count(list[0]) == len(list)

@dataclass
class Cable:
    label:str
    allowable_tension:float
    fact_allowable:float
    tension:list[float]
    usage:list[float]
    guy_size: str="NA"





class Res_File_Reader:
    """A class that contains the lines from a .res file from PLS-tower"""

    def __init__(self, res_file_lines) -> None:

        self.res_file_lines = res_file_lines
        self.nodes = self.find_node_coord()
        self.load_cases = self.find_load_cases()

    @classmethod
    def from_res_file(cls, file_name):
        """"Initializes the object directly from a ."res.file""" ""

        with io.open(file_name,encoding="unicode_escape") as file:
            input_data = []
            for line in file:
                input_data.append(line.strip())

        return cls(input_data)

    def _find_keyword(self, keyword: str, start=0):

        i = start
        while i < len(self.res_file_lines):
            if keyword in self.res_file_lines[i]:
                keyword_index = i
                break
            else:
                i = i + 1
        return keyword_index

    def _cut_list(self, keyword: str, identical_match=False, to_the_end=False) -> list:
        """A function that "cuts" the relevant lines out of the res files list. The input of the function is a keyword, like "#Angle Information""" ""

        if identical_match:
            start = self.res_file_lines.index(keyword)

        else:
            for j in range(len(self.res_file_lines)):
                if keyword in self.res_file_lines[j]:
                    start = j
                    break

        i = start

        # have to pass all the "#" in the res files
        while True:
            if "#" in self.res_file_lines[i]:
                i = i + 1
            else:
                break

        if to_the_end:
            cut_list = self.res_file_lines[i:]
        else:
            no_of_lines = int(self.res_file_lines[i])
            cut_list = self.res_file_lines[i + 1 : i + no_of_lines + 1]

        return cut_list

    def _cut_load_case_lines(self, load_case: str, keyword: str) -> list:
        """Returns relevant lines from the input_load_case"""

        load_case_found = False
        for i in range(len(self.res_file_lines)):
            if load_case in self.res_file_lines[i] and load_case_found == False:
                load_case_found = True

            if load_case_found:

                if keyword in self.res_file_lines[i]:
                    break

        # go past all the "#"
        while True:
            i = i + 1
            if "#" not in self.res_file_lines[i]:
                break

        no_of_lines = int(self.res_file_lines[i])

        return self.res_file_lines[i + 1 : i + no_of_lines + 1]

    def find_elements(self) -> pd.DataFrame:
        """A function that finds all the element in a tower-model from the ".res" file generated by the PLS-tower
        lines: a list of lines from a ".res" file"""

        keyword = "#Angle Information"

        lines = self._cut_list(keyword)


        data = defaultdict(list)

        for line in lines:
            info = line.split(",")

            data["angle_label"].append(info[0].strip("'"))
            data["length"].append(float(info[4]))
            data["origin_x"].append(float(info[5]))
            data["origin_y"].append(float(info[6]))
            data["origin_z"].append(float(info[7]))
            data["end_x"].append(float(info[8]))
            data["end_y"].append(float(info[9]))
            data["end_z"].append(float(info[10]))
        
        return pd.DataFrame(data)
    
    def find_member_group(self)-> pd.DataFrame:

        keyword = "#Member Capacities and Overrides"

        lines = self._cut_list(keyword)


        data = defaultdict(list)
        for line in lines:
            info = line.split(",")

            data["member_label"].append(info[0].strip("'"))
            data["group_label"].append(info[1].strip("'"))
        
        return pd.DataFrame(data)
    

    def parse_angle_info(self)-> pd.DataFrame:
        """A function that returns a dataframe with info about every element parsed from res file."""

        member_groups=self.find_member_group()
        element_size=self.find_element_size()
        angle_information=self.find_elements()

        member_groups.rename(columns={'member_label': 'angle_label'}, inplace=True)
        df_combined =  angle_information.merge(member_groups, on='angle_label')
        df_combined =  df_combined.merge(element_size, on='group_label')



        print(df_combined)
        

        return df_combined


        



        


    def find_element_size(self) -> pd.DataFrame:

        keyword = "#Group Summary"

        lines = self._cut_list(keyword)

        elements = []

        data = defaultdict(list)

        for line in lines:
            info = line.split(",")
            data["group_label"].append(info[0].strip("'"))
            data["group_description"].append(info[1].strip("'"))
            data["angle_type"].append(info[2].strip("'"))
            data["angle_size"].append(info[3].strip("'"))
            data["steel_fy"].append(float(info[4]))



        return pd.DataFrame(data)

    def find_node_coord(self) -> list:
        keyword = "#Angle Information"

        lines = self._cut_list(keyword)

        # nodename, x_coord, y_coord, z_coord
        nodes = set()

        for line in lines:

            info = line.split(",")

            node_1 = (info[1], float(info[5]), float(info[6]), float(info[7]))
            node_2 = (info[2], float(info[8]), float(info[9]), float(info[10]))

            nodes.add(node_1)
            nodes.add(node_2)

        self.nodes = nodes

        return nodes

    def find_foundations(self) -> list:

        """""only works with tower that has 4 foundations.""" ""

        coords = self.nodes

        def _quadrant(x_coord: float, y_coord: float):
            if x_coord > 0 and y_coord > 0:
                return "f1"
            elif x_coord > 0 and y_coord < 0:
                return "f2"
            elif x_coord < 0 and y_coord < 0:
                return "f3"
            elif x_coord < 0 and y_coord > 0:
                return "f4"
            else:
                return None

        _keys = ["f1", "f2", "f3", "f4"]

        _f = OrderedDict.fromkeys(_keys, 0)

        for found in _keys:
            max_z = 0
            for coord in coords:
                if _quadrant(coord[1], coord[2]) == found and coord[3] < max_z:
                    _f[found] = coord[0]
                    max_z = coord[3]

        return list(_f.values())

    def find_loads_foundations(self):
        def find_forces(lines, node_name):

            for line in lines:

                info = line.split(",")

                if info[0] == node_name:
                    forces = ((info[4]), info[5], info[6])
                    forces = tuple(map(float, forces))
                    break

            return forces

        foundations = self.find_foundations()
        keyword = "#Joint Displacements, Loads and Member Forces on Joints"

        forces = [[], [], [], []]

        for load_case in self.load_cases:

            lines = self._cut_load_case_lines(load_case, keyword)

            for j in range(len(foundations)):
                forces[j].append(find_forces(lines, foundations[j]))

        return forces

    def find_load_cases(self, include_index=False):

        keyword = "# loadcases"

        # load_case_index = self.find_keyword(keyword)

        # i = load_case_index

        lines = self._cut_list(keyword, identical_match=False, to_the_end=True)

        load_cases = []

        for line in lines:

            if '"' in line:
                load_case = line
                load_case = load_case[0 : load_case.find('"', 1) + 1]

                load_cases.append(load_case)

        if include_index:
            load_cases = list(zip(range(len(load_cases)), load_cases))

        return load_cases

    def extract_member_forces(self):

        keyword = "#Angle Forces For All Load Cases"
        lines = self._cut_list(keyword)

        data = []

        for line in lines:
            temp = line.split(",")

            element_name = temp[0]
            element_group = temp[1]
            forces = temp[5:]
            forces = tuple(map(float, forces))
            data.append([(element_name, element_group), forces])

        return data

    def extract_node_displacements(self):

        keyword = "#Equilibrium Joint Positions and Rotations"

        data = defaultdict(list)

        for load_case in self.load_cases:

            lines = self._cut_load_case_lines(load_case, keyword)

            for line in lines:
                temp = line.split(",")

                node_name = temp[0]
                disp = tuple(map(float, (temp[1], temp[2], temp[3])))
                data[node_name].append(disp)

        return data
    
    def extract_guy_wire_info(self):

        keyword="#Summary of Cable Tensions and Usages"

        data = defaultdict(list)


        for load_case in self.load_cases:

            lines = self._cut_load_case_lines(load_case, keyword)

            for line in lines:
                temp=line.split(",")

                guy_wire_name=temp[0]

                guy_wire_info=tuple(map(float, (temp[1],temp[2],temp[3], temp[4])))

                data[guy_wire_name].append(guy_wire_info)

        cables=[]

        for label, results in data.items():

            _allowable_tension=[]
            _factored_allowable=[]
            tension=[]
            usage=[]
            for res in results:
                _allowable_tension.append(res[1])
                _factored_allowable.append(res[2])
                tension.append(res[0])
                usage.append(res[3])

            #a little sanity check to check if the allowable tension and factored tenison is the same for all load cases
            # assert all((check_all_same(_allowable_tension),check_all_same(_factored_allowable)))==True,"Something went wrong, check allowable tension and/or factored allowable in cables"

            _cable=Cable(label.replace("'",""),_allowable_tension[0],_factored_allowable[0],tension,usage)

            cables.append(_cable)

        return cables

    def extract_insulator_strain_loads(self):

        keyword="#Summary of Strain Capacities and Usages"

        data = defaultdict(list)


        for load_case in self.load_cases:

            lines = self._cut_load_case_lines(load_case, keyword)

            for line in lines:

                temp = line.split(",")
                strain_label=temp[0].strip("'")
                strain_force=float(temp[1])

                data[strain_label].append(strain_force)

        return data
    
    def extract_suspension_loads(self):
    
        keyword="#Summary of Suspension Capacities and Usages"
        data = defaultdict(list)
        for load_case in self.load_cases:

            lines = self._cut_load_case_lines(load_case, keyword)

            for line in lines:

                temp = line.split(",")
                strain_label=temp[0].strip("'")
                strain_force=float(temp[1])

                data[strain_label].append(strain_force)
            
        return data
    
    def insulator_strain_forces_to_pandas(self):
        strain_loads=self.extract_insulator_strain_loads()

        dataframe=pd.DataFrame()
        dataframe["Load_cases"]=self.load_cases

        for key,value in strain_loads.items():
            dataframe[key]=value


        return dataframe
    
    def suspension_forces_to_pandas(self):
        strain_loads=self.extract_suspension_loads()

        dataframe=pd.DataFrame()
        dataframe["Load_cases"]=self.load_cases

        for key,value in strain_loads.items():
            dataframe[key]=value


        return dataframe








        




if __name__ == "__main__":

    print("Done")